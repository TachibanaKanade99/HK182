\documentclass[a4paper]{article}
\usepackage[a4paper,left=2cm,right=2cm,top=1.8cm,bottom=2.8cm]{geometry}
\usepackage[english]{babel}
\usepackage{pictex,amsmath,amsfonts,amssymb,amsthm,verbatim}
\usepackage{fullpage}
\usepackage{fullpage}
\usepackage{fancyhdr}
\usepackage{algorithm,algorithmic}
\usepackage{multirow}
\usepackage{gensymb}
\usepackage{mathrsfs}

\setlength{\voffset}{-0.25in}
\setlength{\headsep}{+0.5in}
\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\def\vu{\mathbf{u}}
\def\vv{\mathbf{v}}
\def\vb{\mathbf{b}}
\def\vw{\mathbf{w}}
\def\vs{\mathbf{s}}

%Graphics packages:
\usepackage{graphicx, graphics}
\usepackage{tabularx, caption}
\usepackage{multirow, multicol}
\usepackage{setspace, tikz}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{mdframed}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage[utf8]{vietnam}

\newmdenv[linecolor=blue,skipabove=\topsep,skipbelow=\topsep,leftmargin=5pt,rightmargin=-5pt,innerleftmargin=5pt,innerrightmargin=5pt]{mybox}

\newcommand{\quotes}[1]{``#1''}
\usepackage{minted}


%fancyhdr:
\setlength{\headheight}{40pt}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{
 \begin{tabular}{rl}
    \begin{picture}(25, 15)(0, 0)
    \put(0, -8){\includegraphics[width=8mm, height=8mm]{hcmut.png}}
   \end{picture}&
	\begin{tabular}{l}
		\textbf{\bf \ttfamily University of Technology, VNU-HCM}\\
		\textbf{\bf \ttfamily Faculty of Computer Science \& Engineering}
	\end{tabular} 	
 \end{tabular}
}

\fancyhead[R]{
    \begin{tabular}{l}
        \tiny \bf \\
        \tiny \bf
    \end{tabular}
}

\fancyfoot{} %clear all footer fields
\fancyfoot[L]{\scriptsize \ttfamily CC2018 - Operating System (Spring 2019)}
\fancyfoot[R]{\scriptsize \ttfamily Page {\thepage}/ \pageref{LastPage}}
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}

\begin{document}
    \begin{titlepage}
        \begin{center}
            HO CHI MINH CITY UNIVERSITY OF TECHNOLOGY, VNU HCM \\
            FACULTY OF COMPUTER SCIENCE AND ENGINEERING
        \end{center}

        \vspace{1cm}

        \begin{figure}[h!]
            \begin{center}
                \includegraphics[width=3cm]{hcmut.png}
            \end{center}
        \end{figure}

        \vspace{1cm}

        \begin{center}
            \begin{tabular}{c}
                \multicolumn{1}{l}{\textbf{\LARGE OPERATING SYSTEM}} \\
                ~~\\
                \hline
                \\
                \multicolumn{1}{l}{\LARGE Lab 2: C Programming on Linux} \\
                \\
                \hline
                \\
                \hspace{5cm} Pham Minh Tuan - MSSV: 1752595
            \end{tabular}
        \end{center}
    \end{titlepage}

%Newpage:
\newpage

\section{\large Exercises: }
\subsection{\large Questions: }

\begin{enumerate}
    %1
    \item Briefly explain each stage of the compilation process.
    \begin{itemize}
        \item The compilation process includes 4 stages: Preprocessing, Compilation, Assembly, and Linking.
        \begin{itemize}
            \item Preprocessing:
            \begin{itemize}
                \item Lines starting with a \# character are interpreted by the preprocessor as preprocessor commands.
                \item Before interpreting commands, the preprocessor does some initial processing including joining continued lines and stripping comments.
                \item The result of preprocessing stage is generated by command: \\
                \begin{center}
                    gcc -E sourcefile.c
                \end{center}
            \end{itemize}

            \item Compilation:
            \begin{itemize}
                \item In this stage, the preprocessed code is \textbf{translated} into \textbf{assembly instructions} specific to the target processor architecture.
                \item This step allows C code to contain inline assembly instructions and different assemblers to be used.
                \item The result of compilation stage is generated by command: \\
                \begin{center}
                    gcc -S sourcefile.c
                \end{center}
                \item After executing the above command, it will create the output file "sourcefile.s". 
            \end{itemize}

            \item Assembly:
            \begin{itemize}
                \item During this stage, an assembler is used to translated the assembly instructions to object code.
                \item The output consists of actual instructions to be run by the target processor.
                \item The result of the assembly stage is generated by command:
                \begin{center}
                    gcc -c sourcefile.c
                \end{center}
                \item After running the above command will create a file name sourcefile.o containing the object code of program, the contents of this file is in binary format.
            \end{itemize}

            \item Linking:
            \begin{itemize}
                \item The object code generated in compilation stage is composed of machine instructions that the processor understands, however some files of the program are missing. Those missing files needed to be rearranged and filled in $\rightarrow$ Linking stage.
                \item In this stage, The linker will arrange the pieces of object code so that functions in some pieces can successfully call functions in other ones, the linker also add pieces containing the instructions for library functions used by the program.
                \item The result of this stage is the final \textbf{executable program}.
                \begin{center}
                    gcc -o main sourcefile.c
                \end{center}
            \end{itemize}
        \end{itemize}
    \end{itemize}

    %2
    \item Illustrate the compilation process when we have multiple files:
    \begin{itemize}
        \item \% Preprocessed sourcefile \\
        \$ gcc -E transmit.c \\
        \$ gcc -E receive.c \\
        \$ gcc -E main.c      
        \item \% Assembly code \\
        \$ gcc -S transmit.c \\
        \$ gcc -S receive.c \\
        \$ gcc -S main.c
        \item \% Binary file \\
        \$ gcc -c transmit.c \\
        \$ gcc -c receive.c \\
        \$ gcc -c main.c
        \item \% Executable file \\
        \$ gcc -o main main.o transmit.o receive.o
    \end{itemize}
    
    %3
    \item Compiling a program in the first time usually takes a longer time in comparison with the next re-compiling. What is the reason?
    \begin{itemize}
        \item A program takes long time to compile depend on the structures of the program (Ex: struct, ...) or linking header files and object files together.
        \item However since next time recompile will take less time due to linking already built as the first time compilation stage.
    \end{itemize}

    %4
    \item How do we make Makefile for other programming languages ? Use specific examples to support languages.
    \begin{itemize}
        \item To use Makefile for other languages, we can make a general-purpose Makefile to support all types of languages. 
        \item We can define macros and general-purpose command in Makefile to support it. (Ex: "CC=gcc" to define the compilation of C language). \\
        \\
        \includegraphics[width=7cm]{Makefile_Java.png}
        \bigbreak
    \end{itemize}

    %5
    \item When source code files are located in different directories, how can we write a Makefile ?
    \begin{itemize}
        \item Suppose we have .h files in a specific directory and some source code files in src directory, we can define paths to the specific places where .h files were stored.
        \item To include any libraries, Makefile has macros defined for them (Ex: the math library as "LIBS=-lm").
        \item Beside, the created Makefile should be located in the src directory.
    \end{itemize}
\end{enumerate}

\subsection{Programming Exercises}
\begin{enumerate}
    %1
    \item The findsubstr.c I use the KMP algorithm to implement it. So the O-notation is O(m + n), for m is the size of the string, n for the size of the substring.
\end{enumerate}


\end{document}